NOTAS DE RUST - SIGNALS Y EXPRESIONES
======================================

## SIGNALS (use_signal)

Un signal es como una "caja" reactiva que guarda un valor.
Cuando el contenido cambia, Freya re-renderiza los componentes que lo usan.

let mut new_title = use_signal(String::new);  // crea signal con String vacio


## LEER Y ESCRIBIR EN SIGNALS

- .read()  -> Lee el valor (devuelve referencia &String)
- .clone() -> Crea una copia propia del valor
- .set()   -> Escribe/guarda un nuevo valor

value: new_title.read().clone()  // LEE del signal para mostrar
new_title.set(title)             // ESCRIBE al signal para guardar


## POR QUE .clone()?

.read() devuelve una referencia temporal (&String) - como mirar un libro sin llevartelo
.clone() hace una copia independiente - como hacer una fotocopia para llevartela

El Input necesita ser dueno del String, no puede trabajar con una referencia temporal.


## SENTENCIAS VS EXPRESIONES

| Codigo                    | Que pasa?                           |
|---------------------------|-------------------------------------|
| Note { ... }              | Se devuelve (retorna)               |
| Note { ... };             | Se ejecuta y se pierde              |
| let x = Note { ... };     | Se ejecuta y se guarda en x         |

- Con ;  -> Se ejecuta internamente, el valor se descarta
- Sin ;  -> El valor se devuelve/retorna

Si quieres conservar un valor, guardalo en variable con let.


## STRUCT NOTE - SINTAXIS

Los campos se separan con COMAS, no punto y coma:

Note {
    title: valor1,     // coma
    content: valor2,   // coma
}

El ; va DESPUES de cerrar la struct si es una sentencia:

let nota = Note {
    title: new_title.read().clone(),
    content: new_content.read().clone(),
};  // <- el ; va aqui


## CICLO DE UN INPUT

Usuario escribe "Hola"
        |
        v
onchange recibe "Hola"
        |
        v
new_title.set("Hola")  ->  El signal ahora contiene "Hola"
        |
        v
Freya detecta el cambio y re-renderiza
        |
        v
value: new_title.read().clone()  ->  Lee "Hola" y lo muestra en el Input


## VARIABLES Y SCOPE

Una variable solo vive dentro de su bloque { }.
Cuando el bloque termina, la variable muere y se pierde.

onpress: move |_| {
    let nota = Note { ... };
    // nota vive aqui

    // si no haces push, cuando el closure termina, nota se pierde
    notes.write().push(nota);  // <- esto mueve nota al vector, sobrevive
}


## MODIFICAR UN VECTOR EN UN SIGNAL

- .read()  -> Para leer (acceso inmutable)
- .write() -> Para modificar (acceso mutable)

notes.read().iter()      // leer las notas
notes.write().push(nota) // anadir una nota


## CLOSURES - CODIGO DENTRO DE { }

Un closure es una funcion anonima. Todo el codigo debe ir DENTRO de las llaves.

CORRECTO:
onpress: move |_| {
    let nota = Note { ... };
    notes.write().push(nota);   // <- DENTRO del closure
}

INCORRECTO:
onpress: move |_| {
    let nota = Note { ... };
}
notes.write().push(nota);       // <- FUERA del closure, ERROR!

Si el codigo esta fuera del closure:
- No se ejecuta cuando presionas el boton
- La variable 'nota' no existe fuera (ya murio)


## FLUJO COMPLETO DEL BOTON GUARDAR

Button {
    onpress: move |_| {
        // 1. Crear la Note con los valores de los inputs
        let nota = Note {
            title: new_title.read().clone(),
            content: new_content.read().clone(),
        };

        // 2. Anadir la nota al vector
        notes.write().push(nota);

        // 3. Freya detecta el cambio en 'notes' y re-renderiza
        // 4. El for loop en el UI muestra la nueva nota
    }
}

Orden de ejecucion:
1. Usuario presiona el boton
2. Se dispara el closure de onpress
3. Se crea 'nota' con los datos de los inputs
4. Se hace push al vector 'notes'
5. El signal 'notes' cambia -> Freya re-renderiza
6. El for loop ahora incluye la nueva nota
7. La nota aparece en pantalla


## PERSISTENCIA CON JSON (serde)

Las notas en memoria se pierden al cerrar la app.
Para guardarlas en disco usamos JSON con las crates serde y serde_json.

Dependencias en Cargo.toml:
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"


## DERIVES PARA JSON

#[derive(Clone, Serialize, Deserialize)]
struct Note { ... }

- Serialize   -> Permite convertir Note a JSON (guardar)
- Deserialize -> Permite convertir JSON a Note (cargar)


## CARGAR NOTAS (JSON -> Vec<Note>)

fn load_notes() -> Vec<Note> {
    match fs::read_to_string("notas.json") {
        Ok(content) => serde_json::from_str(&content).unwrap_or_else(|_| vec![]),
        Err(_) => vec![],
    }
}

- match evalua si el archivo existe o no
- Ok(content) -> archivo existe, convertir JSON a vector
- Err(_) -> archivo no existe, devolver vector vacio
- unwrap_or_else -> si el JSON esta corrupto, devolver vector vacio


## GUARDAR NOTAS (Vec<Note> -> JSON)

fn save_notes(notes: &Vec<Note>) {
    if let Ok(json) = serde_json::to_string_pretty(notes) {
        let _ = fs::write("notas.json", json);
    }
}

- to_string_pretty -> convierte vector a JSON legible
- fs::write -> escribe el JSON al archivo


## CONVERSION JSON <-> STRUCT

JSON:                              Rust:
{                                  Note {
  "title": "Hola",        <->        title: "Hola".to_string(),
  "content": "Mundo"                 content: "Mundo".to_string(),
}                                  }

Serde mapea automaticamente los campos por nombre.
